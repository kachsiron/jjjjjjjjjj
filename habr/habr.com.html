<!DOCTYPE html>
<html class="no-js fonts-loaded" style="height: 100%;" lang="ru"><head><meta http-equiv="content-type" content="text/html; charset=UTF-8"></head>

  <body class="nl" style="height: 100%; width: 600px; line-height: 1; font-family: Marmelad; font-size: 28px;margin: 0 auto;"><div class="post__wrapper">
    <header class="post__meta">
      <a href="https://habr.com/users/cerberus_ab/" class="post__user-info user-info" title="Автор публикации" style="color: black; text-decoration-style: dashed;">
          <img src="habr.com_files/b686a1a780b4766ff715a01f68879c04.jpg" class="user-info__image-pic user-info__image-pic_small" width="24" height="24">
        <span class="user-info__nickname user-info__nickname_small">cerberus_ab</span>
      </a>

      <span class="post__time">12 декабря 2018 в 10:52</span>

      
    </header>

    <h1 class="post__title post__title_full" style="margin: 0px; font-size: 40px;">
      <span class="post__title-text">Явные возможности JavaScript</span>
    </h1>


      

    <ul class="post__marks inline-list"></ul>

    <div class="post__body post__body_full">
      <div class="post__text post__text-html js-mediator-article"><p style="margin: 0px;"><img src="habr.com_files/f_vy_sw3-w-pyxs4zrpqejzpkq4.jpg" alt="Image" style="width: 600px;"></p><br>
<p style="margin: 0px;">Начитывая очередную статью про малоизвестные фичи языка <strong>JavaScript</strong>
 и втихую пописывая какие-то невменяемые решения в консоли браузера, я 
часто проговариваю в голове мол ну на проде то конечно все не так!? Ведь
 язык давно обзавелся огромнейшим комьюнити и имеет удивительно широкий 
охват промышленной разработки. Раз так, то почему же мы часто забываем 
про его возможность быть понятным для каждого и буквально пропагандируем
 все эти специфичные и "запоминаемые" конструкции? <em>Just make it Obvious!</em></p><a name="habracut" style="color: black; text-decoration-style: dashed;"></a><br>
<h2 id="rassuzhdeniya-na-temu" style="margin: 0px;">Рассуждения на тему</h2><br>
<p style="margin: 0px;"><em>Эту графоманию можно пропустить.</em></p><br>
<p style="margin: 0px;">Если говорить о промышленной разработке, то в 
подавляющем большинстве случаев требование к коду быть поддерживаемым 
даже важнее, чем решать поставленную бизнесом задачу. Для многих это 
очевидно, для некоторых — отчасти (встречаются конечно и редкие 
Д'Артаньяны). Чем понятнее наш код, тем меньше рисков для него — попасть
 на пыльную полку, а для нас и наших преемников — заработать проблем с 
нервной системой.</p><br>
<p style="margin: 0px;">Не секрет, что JavaScript удивителен своей 
гибкостью, что является как его величайшим достоинством, так и досадным 
проклятием. Путь JavaScript-разработчика долог и крайне интересен: мы 
поглощаем книжку за книжкой, статью за статьей и набираемся уникального 
опыта, но местами — действительно language-специфичного. Широчайшее 
распространение языка и в то же время богатое число накопившихся и 
подкармливаемых неочевидностей способствуют образованию двух фронтов: 
тех, кто едва ли не боготворит этот язык, и тех, кто смотрит на него как
 на неуклюжую и качающую права утку.</p><br>
<p style="margin: 0px;">И все бы ничего, но часто представители обоих 
фронтов работают на одном проекте. И обычной, всеми принятой практикой 
является непонимание (нежелание понимать и даже игнорирование) кода друг
 друга. И в самим деле, <em>"я же на Java-разработчика устраивался, а не это ваше!"</em>. Масла в огонь подливают и сами JavaScript-последователи мол <em>"никто на самом деле не знает JavaScript!"</em> да <em>"я могу это в одну строчку написать на js!"</em>. Каюсь, что и сам злоупотребляю на досуге ненормальным программированием...</p><br>
<p style="margin: 0px;">Эту проблему начинаешь чувствовать, когда 
занимаешь место маргинала и приобретаешь некоторый опыт работы с людьми и
 их кодом по обе стороны от баррикад. Планинг и прочие митинги проходят 
продуктивнее, когда все разработчики понимают друг друга не только на 
уровне бизнес-сторей, но и хоть немного на уровне их имплементации. 
Пресловутый <a href="https://medium.com/tech-tajawal/the-bus-factor-6ea1a3ede6bd" style="color: black; text-decoration-style: dashed;">бас-фактор</a>
 меньше сказывается на проекте, когда в случае болезни единственного 
фронт-ендера остальные члены команды не брезгуют поправить какую-то 
строчку <em>.js</em> файла. Процесс обмена знаниями в команде и за ее 
пределы становится прозрачнее для всех, когда каждый имеет более 
детальную картину. Ну и все в том же духе.</p><br>
<p style="margin: 0px;">Я никого не призываю "фулстекнуться" или 
"T-шейпнуться" (как сейчас правильно говорить?), но почему бы нам 
немного не приподнять этот занавес хотя бы со стороны 
JavaScript-сообщества? Для этого достаточно лишь привнести немного 
явности в наш код, используя гибкость языка не чтобы выпендриться, а 
чтобы нас понимали.</p><br>
<h2 id="vzroslenie-i-prinyatie-otvetstvennosti" style="margin: 0px;">Взросление и принятие ответственности</h2><br>
<p style="margin: 0px;">Со своей стороны JavaScript уже давно осознал 
свою роль не как язык для интерактивности интернет-страничек и 
"склеивания" их ресурсов, но как мощнейший и достаточный инструмент 
создания полноценных кросс-платформенных и часто очень даже 
масштабируемых приложений. </p><br>
<p style="margin: 0px;">Изначально разработанный для веб-дизайнеров этот
 "самый неправильно понятый язык программирования" долгое время топтался
 на месте, несмотря на стремительно растущую популярность и значимость. 
За 13-14 лет, предшествующие редакции ECMAScript 5.1, трудно вспомнить 
какие-то важные изменения в стандарте или понять вектор его развития. В 
то время огромный вклад в формирование экосистемы языка вносило его 
комьюнити: Prototype, jQuery, MooTools и проч. Получив эту обратную 
связь от разработчиков, JavaScript проделал значительную работу над 
ошибками: громкий 6-летний релиз ES6 в 2015 году и теперь уже ежегодные 
релизы ECMAScript, благодаря переработанному комитетом TC39 процессу <a href="https://frontender.info/tc39-process/" style="color: black; text-decoration-style: dashed;">внесения новых возможностей</a> в спецификацию.</p><br>
<p style="margin: 0px;">Что ж, когда наши приложения стали достаточно 
большими, прототипная модель ООП для описания пользовательских типов 
перестала себя оправдывать из-за непривычного подхода. Ну серьезно, что 
это?</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{
<span class="hljs-comment"><span class="hljs-comment">/* Call me via new and I will be the constructor ;) */</span></span>
}
<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}

Rabbit.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Animal.prototype);
Rabbit.prototype.constructor = Rabbit;</code></pre><br>
<p style="margin: 0px;">В языке не появились классы, но появился их 
синтаксис. И код стал доступен для приверженцев традиционной 
класс-ориентированной парадигмы:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {
    <span class="hljs-comment"><span class="hljs-comment">/* Obviously, the constructor is here! */</span></span>
    }
}
<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{}</code></pre><br>
<p style="margin: 0px;">Сейчас на стадии кандидата в релиз находятся <a href="https://github.com/tc39/proposal-class-fields" style="color: black; text-decoration-style: dashed;">приватные поля</a>
 класса. С трудом верится, что рано или поздно мы перестанем смешить 
друг друга соглашением об именовании приватных свойств через нижнее 
подчеркивание.</p><br>
<p style="margin: 0px;">В то же время, в языке, где функция является 
объектом первого порядка и имеет место постоянная событийность, 
совершенно обычное дело:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;
setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{
    that.n += <span class="hljs-number"><span class="hljs-number">1</span></span>;
}, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code></pre><br>
<p style="margin: 0px;">И тут начинаются объяснения о контекстах <em>this</em>
 и замыкании в JavaScript, что отпугивает каждого второго внешнего 
разработчика. Но во многих случаях, язык позволяет избежать лишних 
удивлений, явно используя <em>Function.prototype.bind</em> или вовсе так:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code></pre><br>
<p style="margin: 0px;">У нас тоже появились стрелочные функции, и это 
действительно — функции, а не функциональные интерфейсы (да, Java?). 
Вместе с расширенным набором методов работы с массивом они также 
помогают писать привычный декларативный пайплайн вычислений:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;">[<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]
  .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)
  .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, x))
  .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, x</span></span></span><span class="hljs-function">) =&gt;</span></span> s + x, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code></pre><br>
<p style="margin: 0px;">Язык по праву считает себя мультипарадигменным. Но вот простой пример про сигнатуру некоторой функции:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{
    count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>;
    <span class="hljs-comment"><span class="hljs-comment">/* send ping to host count times */</span></span>
}</code></pre><br>
<p style="margin: 0px;">Сначала проходящий мимо задастся вопросом мол 
вероятно функция может принимать только первый аргумент, а потом мол 
какого черта в этом случае <em>count</em> становится булевом!? И действительно, функция имеет два варианта использования: с указанием <em>count</em> и без. Но это совершенно неочевидно: приходится смотреть в реализацию и понимать. Разобраться может помочь использование <a href="http://usejsdoc.org/" style="color: black; text-decoration-style: dashed;">JSDoc</a>,
 но это не общепринятая практика. И здесь JavaScript пошел навстречу, 
добавив поддержку не перегрузки, но хотя бы дефолтных параметров:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code></pre><br>
<p style="margin: 0px;">Резюмируя, JavaScript обзавелся огромным числом привычных вещей: генераторы, итераторы, коллекции <em>Set</em> и словари <em>Map</em>, типизированные массивы, да даже регулярные выражения начали радовать поддержкой <em>lookbehind</em>! Язык делает все, чтобы быть пригодным для многих вещей и стать дружелюбным для всех.</p><br>
<h2 id="blagopriyatnyy-put-k-ochevidnomu" style="margin: 0px;">Благоприятный путь к очевидному</h2><br>
<p style="margin: 0px;">Сам язык — безусловно молодец, и с этим трудно 
спорить! Но что не так с нами? Почему мы постоянно напоминаем всему 
миру, что JavaScript все таки какой-то не такой? Давайте посмотрим на 
примеры некоторых широко используемых приемов и зададимся вопросом их 
целесообразности.</p><br>
<h3 id="privedenie-tipov" style="margin: 0px;">Приведение типов</h3><br>
<p style="margin: 0px;">Да, JavaScript обладает динамической и слабой 
системой типов и позволяет проводить операции над чем угодно, неявно 
выполняя за нас преобразования. Но часто явное приведение типов нам все 
таки необходимо и можно наблюдать следующее:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = !!(expr);
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = +(expr);
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">''</span></span>+(expr);</code></pre><br>
<p style="margin: 0px;">Эти трюки известны каждому 
JavaScript-разработчику и мотивируются они тем, что мол так можно 
"быстро" превратить что-то во что-то: под быстротой здесь понимается 
короткая запись. Может еще и <em>false</em> записывать сразу как <em>!1</em>? Если разработчик так сильно переживает за печатаемые символы, то в его любимой IDE можно без труда настроить необходимый <em>live template</em>
 или автокомплит. А если — за размер публикуемого кода, то мы всегда 
прогоняем его через обфускатор, который знает получше нашего как все это
 обесчеловечить. Почему не так:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(expr);
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(expr);
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(expr);</code></pre><br>
<p style="margin: 0px;">Результат — такой же, только понятен всем.</p><br>
<p style="margin: 0px;">Для строковых преобразований у нас есть <em>toString</em>, но для численных есть интересный <em>valueOf</em>, который может быть тоже переопределен. Классический пример, который вводит в ступор "непосвященных":</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>;</code></pre><br>
<p style="margin: 0px;">Но ведь есть у <em>Date</em> известный метод <em>getTime</em>, давайте использовать его:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()).getTime();</code></pre><br>
<p style="margin: 0px;">или готовую функцию:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();</code></pre><br>
<p style="margin: 0px;">Абсолютно незачем эксплуатировать неявное приведение типов.</p><br>
<h3 id="logicheskie-operatory" style="margin: 0px;">Логические операторы</h3><br>
<p style="margin: 0px;">Отдельного внимания достойны логические 
операторы И (&amp;&amp;) и ИЛИ (||), которые в JavaScript не совсем 
логические: принимают и возвращают значения любого типа. Вдаваться в <a href="https://learn.javascript.ru/logical-ops" style="color: black; text-decoration-style: dashed;">детали работы вычислителя</a> логического выражения не будем, рассмотрим примеры. Ранее представленный вариант с функцией:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{
    count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>;
    <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>
}</code></pre><br>
<p style="margin: 0px;">Вполне может выглядеть следующим образом:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{
    <span class="hljs-comment"><span class="hljs-comment">// OR arguments.length?</span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> count == <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) {
        count = <span class="hljs-number"><span class="hljs-number">5</span></span>;
    }
    <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>
}</code></pre><br>
<p style="margin: 0px;">Такая проверка и привычней, и в некоторых случаях может помочь избежать ошибки.</p><br>
<p style="margin: 0px;">Это скорее кажется дикостью для разработчика, 
который изначально выбрал путь JavaScript. Но для большинства других — 
вот этот код действительно дикий:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> self == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; self.self === self &amp;&amp; self) ||
    (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> global == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; global.global === global &amp;&amp; global);</code></pre><br>
<p style="margin: 0px;">Да, это компактно, и да, это могут позволить 
себе популярные библиотеки. Но, пожалуйста, давайте не злоупотреблять 
этим, так как наш код будут читать не контрибьюторы в JavaScript, а 
разработчики, решающие бизнес-задачи за выделенные сроки.</p><br>
<p style="margin: 0px;">Может встретиться и вовсе такой паттерн:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> opts == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; opts.count || <span class="hljs-number"><span class="hljs-number">5</span></span>;</code></pre><br>
<p style="margin: 0px;">Это определенно короче обычного тернарного 
оператора, но при чтении такого кода первым делом вспоминаешь приоритеты
 используемых операций.</p><br>
<p style="margin: 0px;">Если же мы пишем функцию-предикат, которую передаем в тот же <em>Array.prototype.filter</em>, то обернуть возвращаемое значение в <em>Boolean</em>
 — это хороший тон. Сразу становится очевидно назначение этой функции и 
не возникает диссонанса у разработчиков, языки которых имеют 
"правильные" логические операторы.</p><br>
<h3 id="pobitovye-operacii" style="margin: 0px;">Побитовые операции</h3><br>
<p style="margin: 0px;">Распространенный пример проверки наличия 
элемента в массиве или подстроки в строке с помощью побитового НЕ (NOT),
 который предлагается даже некоторыми учебниками:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">1</span></span>)) {
    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'yes'</span></span>);
}</code></pre><br>
<p style="margin: 0px;">Какую проблему это решает? нам не приходится осуществлять проверку <em>!== -1</em>, так как <em>indexOf</em>
 получит индекс элемента или -1, а тильда прибавит 1 и поменяет знак. 
Тем самым выражение будет оборачиваться "ложью" в случае индекса -1.</p><br>
<p style="margin: 0px;">Но избежать дублирования кода можно и 
по-другому: вынести проверку в отдельную функцию какого-нибудь 
utils-объекта, как это делают все, чем использовать побитовые операции 
не по назначению. В lodash для этого есть функция <a href="https://lodash.com/docs/4.17.10#includes" style="color: black; text-decoration-style: dashed;">includes</a>, и работает она не через <del>жопу</del> тильду. Можно возрадоваться, так как в ECMAScript 2016 закрепился метод <em>Array.prototype.includes</em> (у строк тоже есть). </p><br>
<p style="margin: 0px;">Но не тут-то было! Еще тильду (наравне с XOR) используют для округления числа, отбрасывая десятичную часть:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(~~<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span>
<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">2.72</span></span>^<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code></pre><br>
<p style="margin: 0px;">Но ведь есть <em>parseInt</em> или <em>Math.floor</em>
 для этих целей. Побитовые операции здесь удобны для быстрого набора 
кода в консоли, так как они к тому же имеют низкий приоритет перед 
остальной арифметикой. Но на код-ревью такое лучше не пропускать.</p><br>
<h3 id="sintaksis-i-konstrukcii-yazyka" style="margin: 0px;">Синтаксис и конструкции языка</h3><br>
<p style="margin: 0px;">Некоторые странные практики трудно отнести к 
какому-то конкретному разделу. Например, говорят, что скобки при вызове 
конструктора необязательны и следующие два выражения идентичны:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit();

<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit;</code></pre><br>
<p style="margin: 0px;">И это действительно так! но зачем создавать 
вопрос на пустом месте? Не каждый язык может похвастать такой 
"особенностью". А если все таки хочется, то пусть это будет соглашением 
по всему проекту. Иначе возникает ложное чувство, что есть какая-то 
разница.</p><br>
<p style="margin: 0px;">Похожая ситуация с объявлением набора переменных. Синтаксис директив <em>var</em> и <em>let</em> позволяет объявить (и определить) сразу несколько переменных, перечисленных через запятую:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>, host, retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code></pre><br>
<p style="margin: 0px;">Кто-то использует переводы строк для читаемости,
 но в любом случае такой синтаксис — не частое явление в популярных 
языках. Никто не даст по рукам и не спросит, если написать так:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>;
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;
<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> host;</code></pre><br>
<p style="margin: 0px;">Опять таки, если есть соглашение о хорошем стиле
 на уровне проекта/компании, то вопросов нет. Просто не надо чересчур 
комбинировать варианты синтаксиса по настроению.</p><br>
<p style="margin: 0px;">Есть в языке и вовсе специфичные конструкции, 
как например IIFE — позволяет вызвать функцию сразу по месту ее 
определения. Весь трюк в том, чтобы парсер распознал функциональное 
выражение, а не декларацию функции. И это можно сделать уймой разных 
способов: классически обернув скобками, через <em>void</em> или любой 
другой унарный оператор. И в этом нет ничего замечательного! Необходимо 
выбрать единственный вариант и не отходить от него без необходимости:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{
<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>
}());</code></pre><br>
<p style="margin: 0px;">Не надо использовать операторы, чтобы хакнуть 
парсер. Когда на проект приходит новичок, хочется погрузить его в 
бизнес-логику приложения, а не кормить объяснениями откуда были 
подсмотрены все эти восклицательные знаки и войды. Есть еще вторая 
классическая запись через скобки и интересный <a href="https://www.youtube.com/watch?v=eGArABpLy0k&amp;t=1m10s" style="color: black; text-decoration-style: dashed;">комментарий от Крокфорда</a> по этому поводу.</p><br>
<p style="margin: 0px;">Появление синтаксиса классов в ES6 не было 
сопровождено привычными модификаторами доступа. А иногда разработчику 
хочется и на классах пописать, и приватность соблюсти. Что приводит к 
такому коду Франкенштейна:</p><br>
<pre><code class="javascript hljs" style="font-size: 21px; white-space: pre-wrap; overflow-wrap: break-word;"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{
    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {
        <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _name = name;
        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; }
    }
    toString() {
        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.getName()}</span></span></span><span class="hljs-string">`</span></span>;
    }
}</code></pre><br>
<p style="margin: 0px;">То есть в конструкторе для экземпляра создаются 
аксессоры, а приватность достигается их доступом к локальным 
переменным-свойствам через замыкание. Этот пример выглядит вполне даже 
лакончино, но это совершенно немасштабируемый подход, если вокруг него 
не построить документированное решение-фреймворк. Господа, давайте 
использовать либо имеющиеся классы (и ждать стандартизации приватных 
полей), либо популярный паттерн-модуль. Создавать какое-то промежуточное
 микс-решение здесь — такое себе, так как классы перестают быть 
классами, а код — вразумительным.</p><br>
<p style="margin: 0px;">Подытоживая, здравой мыслью будет поделиться 
принятым в проекте стайл-гайдом, конфигом для линтера или просто 
фрагментами кода с коллегами, которые вносят в проект его не-JavaScript 
составляющую. Язык предлагает несколько вариантов буквально для каждой 
типовой задачи, поэтому улучшить понимание друг друга и попасть под 
общий знаменатель не составит труда (ну или почти).</p><br>
<h2 id="zloklyuchenie" style="margin: 0px;">Злоключение</h2><br>
<p style="margin: 0px;">Тема эта конечно холиварная и примеров можно 
привести гораздо больше, но основной посыл статьи о том, что не следует 
злоупотреблять неочевидностями в JavaScript там, где этого можно 
избежать. Природа языка — уникальна: позволяет писать как элегантные и 
выразительные (в меру "упоротые") решения, так и понятные и доступные 
для всех. Я в корне не согласен с расхожим мнением, что JavaScript "сам 
себя наказал" или "похоронен под грудой добрых намерений и ошибок". 
Потому что сейчас большую часть странностей демонстрирует не язык, а 
образовавшаяся вокруг него культура разработчиков и (не)равнодушных.</p></div>
      
      
<script class="js-mediator-script">!function(e){function t(t,n){if(!(n in e)){for(var r,a=e.document,i=a.scripts,o=i.length;o--;)if(-1!==i[o].src.indexOf(t)){r=i[o];break}if(!r){r=a.createElement("script"),r.type="text/javascript",r.async=!0,r.defer=!0,r.src=t,r.charset="UTF-8";var d=function(){var e=a.getElementsByTagName("script")[0];e.parentNode.insertBefore(r,e)};"[object Opera]"==e.opera?a.addEventListener?a.addEventListener("DOMContentLoaded",d,!1):e.attachEvent("onload",d):d()}}}t("//mediator.mail.ru/script/2820404/","_mediator")}(window);</script>
    </div>

    

    
  </div></body></html>